import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long mod = 1000000000L;
        // 점화식 : (n-1) * (d[n-1] + d[n-2])

        int[] d = new int[1000001];
        d[0] = 0;
        d[1] = 0;
        d[2] = 1;
        d[3] = 2;

        for (int i = 4; i <= n; i++) {
            // d[i] = ((i - 1) * (d[i - 1] + d[i - 2])); 
            d[i] = (int)((((i - 1L) % mod) * ((d[i - 1] + d[i - 2]) % mod)) % mod);
            
        }

        System.out.println(d[n]);
    }
}

// 3명 a b c
// a->b a->c
// b->a b->c
// c->a c->b

// 4명 a b c d
// a->b a->c a->d
// b->a b->c b->d
// c->a c->b c->d
// d->a d->b d->c

// n명
// (n-1) * n

// n <= 100만
// n^2 => 너무 큼

// ------ 이게 아님 문제에서 보면 각자 선물을 하나씩만 준비했음
// 위의 경우는 자기자신을 제외하고 모두에게 선물을 주는 경우임
// 따라서 하나의 선물을 한명한테 주되 모두가 자기자신을 제외한 경우를 찾아야함

// 3명 a,b,c
// a->b b->c c->a 
// a->c b->a c->b
// 이렇게 두개뿐임

// a가 줄 수 있는 경우는 b or c 2가지
// b or c가 받았으면 다음 줄 수 있는 수는 1가지
// 첫번째사람은 n-1명한테 주는 경우의 수가 있고
// 첫번째는 줬으니 나머지 n-1명이 다른사람에게 줄 수 있는 경우의 수는 n-2가지

// 이 반복을 4명으로 예시 세워보면 n-2가지 수 이후부터는 3명일떄의 경우를 쓰는 것과 같다 -> 점화식
// 4명 a b c d

// 1명 -> 0가지 : d[1] = 0
// 2명 -> 1가지 : d[2] = 1
// 3명 -> 2가지 -> (3-1가지) * d[2]
// 4명 -> (4-1가지) * d[3]

// --------- 이게 또 아니다
// a,b,c 있을 때
// a는 n-1가지 선택 가능(b or c)
// b라고 하면 b도 역시 n-1 가능 (a or c)
// 그럼 마지막 c는 b한테 못주기때문에 a한테밖에 못줌 n-2임

// 4명 a,b,c,d 일때
// a는 n-1가지, (b or c or d)
// b라고할때 b->a 면 n-1가지 
// a한테 안준다고하면 c,d밖에 선택지 없으므로 n-2가지

// 첫번째 사람은 무조건 n-1가지 경우의 수가 있고
// 그 이후부터는 d[n-1]까지의 선택과 d[n-2]가지의 선택이 조합된다.
// (n-1) * d[n-1]
// (n-1) * d[n-2] 의 경우가 모두 동시에 고려되어야 한다.
// -> (n-1) * (d[n-1] + d[n-2])

// for문 내에서 n이 폭증할 수 있으므로
// 결과에서 % mod 하지 말고 입력 넣을때 각각 mod 해줘서 넣는다.
// (a + b) % mod = (a % mod) + (b % mod)
// (a x b) % mod = (a % mod) x (b % mod) 
// 각각의 연산에서 modular 가능